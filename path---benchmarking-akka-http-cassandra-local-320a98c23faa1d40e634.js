webpackJsonp([0xc395c68b0752],{412:function(e,t){e.exports={data:{site:{siteMetadata:{title:"Akka, Concurrency, etc.",author:"Richard Imaoka"}},markdownRemark:{id:"C:/Users/richardimaoka/blog/src/pages/benchmarking-akka-http-cassandra-local/index.md absPath of file >>> MarkdownRemark",html:'<h2>Overview</h2>\n<p>Although what I tried here does not give realistic or useful results, this is another step forward in my experiment to set up benchmarking environment for Akka and Akka HTTP. I am going to add persistence to Cassandra to the system, to see how the benchmark figures are affected.</p>\n<p>The source code is available <a href="https://github.com/richardimaoka/resources/tree/master/akka-http-cassandra">here</a></p>\n<h2>Results</h2>\n<p>In the previous article, <a href="../hello-world-http-bench/">Benchmarking Spray and Akka HTTP Hello World servers</a>, the web server just returned the constant response. Here I am comparing three different types of web servers.</p>\n<ol>\n<li>Akka HTTP server with JSON marshalling/unmarshalling</li>\n<li>Akka HTTP server with JSON marshalling/unmarshalling, and in-memory persistence</li>\n<li>Akka HTTP server with JSON marshalling/unmarshalling, and akka-persistence-cassandra</li>\n</ol>\n<p>Like explained in the previous article, the 1st attempt in benchmarking could be affected by incomplete JIT compliation. So I only show results from the 2nd and 3rd attempts here.</p>\n<p><img src="/blog/result-throughput-3544dab712b097d012ff0e9a0bdcd1c2.png" alt="result-throughput"></p>\n<table>\n<thead>\n<tr>\n<th align="left">Attempt</th>\n<th align="right">1. JSON</th>\n<th align="center">2. In-Memory</th>\n<th align="center">3. Cassandra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">2nd attempt</td>\n<td align="right">52,196 req/sec</td>\n<td align="center">27,507 req/sec</td>\n<td align="center">992 req/sec</td>\n</tr>\n<tr>\n<td align="left">3rd attempt</td>\n<td align="right">48,293 req/sec</td>\n<td align="center">30,746 req/sec</td>\n<td align="center">1,122 req/sec</td>\n</tr>\n</tbody>\n</table>\n<p>Comparing the throughput, obviously adding Cassandra and <strong>wait the HTTP response until Cassandra persistence is done</strong> makes the performance order of magnitude going down, and the CPU usage for 3 were around 40% although that of 1 and 2 topped at 100% like the prevoius article. (i.e.) The bottleneck is shifted to database I/O from CPU resource competition between the web client and server.</p>\n<p><img src="/blog/task-manager-cassandra-28eacb07076bda4e4e3e719c9ea2bbd4.png" alt="task-manager-cassandra"></p>\n<p>The below is the comparison of average latency,</p>\n<p><img src="/blog/result-avg-e50ee60c1c8f0bb8139a305139f4fee7.png" alt="result-avg"></p>\n<table>\n<thead>\n<tr>\n<th align="left">Attempt</th>\n<th align="right">1. JSON</th>\n<th align="center">2. In-Memory</th>\n<th align="center">3. Cassandra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">2nd attempt</td>\n<td align="right">2.17 millisec</td>\n<td align="center">2.41 millisec</td>\n<td align="center">101.55 millisec</td>\n</tr>\n<tr>\n<td align="left">3rd attempt</td>\n<td align="right">2.16 millisec</td>\n<td align="center">2.10 millisec</td>\n<td align="center">88.92 millisec</td>\n</tr>\n</tbody>\n</table>\n<p>and the max latency.</p>\n<p><img src="/blog/result-max-f3d8c0283cbc8fde4f269ae52a69683d.png" alt="result-max"></p>\n<table>\n<thead>\n<tr>\n<th align="left">Attempt</th>\n<th align="right">1. JSON</th>\n<th align="center">2. In-Memory</th>\n<th align="center">3. Cassandra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">2nd attempt</td>\n<td align="right">321.87 millisec</td>\n<td align="center">452.84 millisec</td>\n<td align="center">335.73 millisec</td>\n</tr>\n<tr>\n<td align="left">3rd attempt</td>\n<td align="right">267.60 millisec</td>\n<td align="center">119.31 millisec</td>\n<td align="center">199.44 millisec</td>\n</tr>\n</tbody>\n</table>\n<p>From here, let\'s see how I set up the servers for 1, 2 and 3.</p>\n<h2>1. JSON marshalling/unmarshalling</h2>\n<p>I am not going in detail, but JSON marshalling is converting a Scala case class instance to JSON payload, and unmarshalling is the opposite.</p>\n<p><img src="/blog/json-marshalling-f0d34e54e0382932b6cdb0928eba76fe.jpg" alt="json-marshalling"></p>\n<p>This HttpServer does simple stuff, to sum up all the <code>"score"</code> sent in HTTP responses, and return the current total, average and number of trials (number of HTTP requests) so far.</p>\n<p>Let\'s define case classes to marshall to/unmarshall from JSON:</p>\n<pre><code class="language-scala">//JSON request {"score": 10} can be unmarshalled to this\ncase class ScoringRequest(\n  score: Double\n)\n\n//This case class can be marshalled to JSON response {"averageScore": ... }\ncase class ScoreResponse(\n  averageScore: Double,\n  totalScore: Double,\n  numberOfTrials: Long\n)\n</code></pre>\n<p>To enable marshlling and unmarshalling, I used <code>SprayJsonSupport</code> as follows: </p>\n<pre><code class="language-scala">import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport\nimport spray.json.DefaultJsonProtocol\n\nobject ScoringJsonSupport extends DefaultJsonProtocol with SprayJsonSupport {\n  implicit val scoringRequestFormat = jsonFormat1(ScoringRequest)\n  implicit val scoreResponseFormat = jsonFormat3(ScoreResponse)\n}\n</code></pre>\n<p>And the route becomes like this.</p>\n<pre><code class="language-scala">import ScoringJsonSupport._\n...\nval routes: Route =\n  path("scoring") {\n    post {\n      entity(as[ScoringRequest]) { request =>\n        updateState(request.score)\n        complete {\n          ScoreResponse(averageScore, totalScore, numberOfTrials)\n        }\n      }\n    }\n  }\n</code></pre>\n<p>For those who are intersted, <a href="https://github.com/richardimaoka/resources/blob/master/akka-http-cassandra/src/main/scala/example/HttpNoPersistentServer.scala">the full HttpServer code</a> is as follows:</p>\n<pre><code class="language-scala">import java.io.{PrintWriter, StringWriter}\n\nimport akka.actor.ActorSystem\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.server.{Directives, Route}\nimport akka.stream.ActorMaterializer\nimport akka.util.Timeout\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\n\nobject HttpNoPersistentServer extends Directives {\n  def main(args: Array[String]): Unit = {\n    import ScoringJsonSupport._\n\n    implicit val system: ActorSystem = ActorSystem("HttpNoPersistentServer")\n    implicit val materializer: ActorMaterializer = ActorMaterializer()\n\n    implicit val timeout: Timeout = 3.seconds\n\n    var averageScore: Double = 0\n    var totalScore:   Double = 0\n    var numberOfTrials: Long = 0\n\n    def updateState(score: Double): Unit ={\n      totalScore = totalScore + score\n      numberOfTrials = numberOfTrials + 1\n      averageScore = totalScore / numberOfTrials\n    }\n\n    try {\n      val routes: Route =\n        path("scoring") {\n          post {\n            entity(as[ScoringRequest]) { request =>\n              updateState(request.score)\n              complete {\n                ScoreResponse(averageScore, totalScore, numberOfTrials)\n              }\n            }\n          }\n        }\n\n      Http().bindAndHandle(routes, "localhost", 8095)\n      println(s"Server online at http://localhost:8095/")\n      Await.result(system.whenTerminated, Duration.Inf)\n    } catch {\n      case t: Throwable =>\n        val sw = new StringWriter\n        t.printStackTrace(new PrintWriter(sw))\n        println(t.getMessage)\n        println(sw)\n    }\n  }\n}\n</code></pre>\n<p><a href="https://github.com/wg/wrk/issues/267">To send a JSON request by wrk</a>, you need to write a lua script like this: </p>\n<pre><code>wrk.method = "POST"\nwrk.body   = \'{"score": 10}\'\nwrk.headers["Content-Type"] = "application/json"\n</code></pre>\n<p>I saved it as <code>wrk-script.lua</code>, and ran the following command:</p>\n<pre><code>$ wrk -t2 -c100 -d30s  -s wrk-script.lua http://localhost:8095/scoring\n</code></pre>\n<p>The results were already pasted at the beginning of this article.</p>\n<h2>2. In-Memory persistence</h2>\n<p><img src="/blog/in-memory-f620aaeb90877b05fd3d23a9ac44a0a8.jpg" alt="in-memory"></p>\n<p>Now I\'m adding persistence to the system, but before doing it with Cassandra, I\'m using in-memory persistence. The persistent actor code is as follows:</p>\n<pre><code class="language-scala">class ScoringActor extends PersistentActor {\n  import ScoringActor._\n\n  var averageScore: Double = 0\n  var totalScore:   Double = 0\n  var numberOfTrials: Long = 0\n\n  def persistenceId = "scoring"\n\n  def updateState(score: Double): Unit ={\n    totalScore = totalScore + score\n    numberOfTrials = numberOfTrials + 1\n    averageScore = totalScore / numberOfTrials\n  }\n\n  def receiveCommand = {\n    case ScoringCommand(score) =>\n      val _sender = sender()\n      persist(ScoringEvent(score)) {\n        evt => updateState(evt.score)\n          _sender ! ScoreResponse(\n            averageScore,\n            totalScore,\n            numberOfTrials\n          )\n      }\n  }\n\n  override def receiveRecover = {\n    case evt: ScoringEvent =>\n      updateState(evt.score)\n  }\n}\n\nobject ScoringActor {\n  case class ScoringCommand(score: Double)\n  case class ScoringEvent(score: Double)\n}\n</code></pre>\n<p>The HttpServer code needs to instantiate the persistent actor (<code>ScoringActor</code>) and do <code>scoringActor ? ScoringCommand(request.score)</code> to perform persistence.</p>\n<pre><code class="language-scala">import ScoringJsonSupport._\n\nimplicit val system: ActorSystem = ActorSystem("HttpPersistentServer")\nimplicit val materializer: ActorMaterializer = ActorMaterializer()\n\nval scoringActor = system.actorOf(Props[ScoringActor], "scoring")\n\nimplicit val timeout: Timeout = 3.seconds\n\nval routes: Route =\n  path("scoring") {\n    post {\n      entity(as[ScoringRequest]) { request =>\n        complete {\n          (scoringActor ? ScoringCommand(request.score)).mapTo[ScoreResponse]\n        }\n      }\n    }\n  }    \n</code></pre>\n<p>here is <code>application.conf</code>:</p>\n<pre><code>akka {\n  loggers = ["akka.event.slf4j.Slf4jLogger"]\n\n  persistence {\n    journal {\n      plugin = "akka.persistence.journal.inmem"\n    }\n    snapshot-store {\n      plugin = "akka.persistence.snapshot-store.local"\n    }\n  }\n}\n</code></pre>\n<p>As in the results we saw earlier, it became slower than 1. JSON marshalling/unmarshalling, because there is communication between the server and the persistent actor. However, the persistent <strong>actor</strong> itself is still lightweight, compared to the actual persistence to Cassandra which I\'ll explain next.</p>\n<h2>3. Persistence to Cassandra</h2>\n<p><img src="/blog/cassandra-8529bc064b866354443cb375e34bc1f6.jpg" alt="cassandra"></p>\n<p>Finally we do real persistence. application.conf becomes this:</p>\n<pre><code>akka {\n  loggers = ["akka.event.slf4j.Slf4jLogger"]\n\n  persistence {\n    journal {\n      plugin = "cassandra-journal"\n    }\n    snapshot-store {\n      plugin = "cassandra-snapshot-store"\n    }\n  }\n}\n</code></pre>\n<p>And you would also need this logback.xml otherwise the log is filled up by a lot of DEBUG level messages from the Cassandra library.</p>\n<pre><code>&#x26;ltconfiguration&#x26;gt\n    &#x26;ltappender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&#x26;gt\n        &#x26;lt!-- encoders are assigned the type\n             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&#x26;gt\n        &#x26;ltencoder&#x26;gt\n            &#x26;ltpattern&#x26;gt%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&#x26;lt/pattern&#x26;gt\n        &#x26;lt/encoder&#x26;gt\n    &#x26;lt/appender&#x26;gt\n\n    &#x26;ltlogger name="com.datastax.driver.core.Connection"  level="WARN" additivity="false" /&#x26;gt\n    &#x26;ltlogger name="com.datastax.driver"                  level="WARN" additivity="false" /&#x26;gt\n\n    &#x26;ltroot level="INFO"&#x26;gt\n        &#x26;ltappender-ref ref="STDOUT" /&#x26;gt\n    &#x26;lt/root&#x26;gt\n&#x26;lt/configuration&#x26;gt\n</code></pre>\n<p>No need to change the Scala code.</p>\n<h2>Lessons learned</h2>\n<p>Even before conducting the benchmark, we could have guessed that Cassandra would be the bottleneck of the system, as database I/O is typically the performance bottleneck of a web applicaiton system.</p>\n<p>However, <strong>to know how much the difference is</strong>, experiment is necessary. So I went through the process on how to distinguish the performance overhead of a single component from all the other , and you can apply the same technique to analyze any component in your system.</p>\n<p>Next step, I want to dockerize this performance experiment environment so that we can run it in the cloud. Also later on I want to Kubernet-ize this and hopefully the deployment and running of the performance test is just a breeze!!</p>\n<p>It\'s getting interesting to me :)</p>\n<h2>References</h2>\n<ul>\n<li>Marshalling and Unmarshalling in Akka HTTP at - <a href="https://doc.akka.io/docs/akka-http/2.5/common/marshalling.html#marshalling">https://doc.akka.io/docs/akka-http/2.5/common/marshalling.html#marshalling</a></li>\n<li>Persistent actor at - <a href="https://doc.akka.io/docs/akka/2.5/persistence.html">https://doc.akka.io/docs/akka/2.5/persistence.html</a></li>\n<li>akka-cassandra at <a href="https://github.com/akka/akka-persistence-cassandra">https://github.com/akka/akka-persistence-cassandra</a></li>\n</ul>',frontmatter:{title:"Locally Benchmarking Akka HTTP with akka-persistence-cassandra",date:"March 11, 2018"}}},pathContext:{slug:"/benchmarking-akka-http-cassandra-local/"}}}});
//# sourceMappingURL=path---benchmarking-akka-http-cassandra-local-320a98c23faa1d40e634.js.map