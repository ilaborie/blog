webpackJsonp([0xc6a074d4bb50],{411:function(e,t){e.exports={data:{site:{siteMetadata:{title:"Akka, Concurrency, etc.",author:"Richard Imaoka"}},markdownRemark:{id:"C:/Users/richardimaoka/blog/src/pages/akka-http-quickstart/index.md absPath of file >>> MarkdownRemark",html:'<h2>Overview</h2>\n<p>In this article, I am going to show how to:</p>\n<ul>\n<li>Run an Akka HTTP server,</li>\n<li>Convert to JSON from Scala case classes,</li>\n<li>Use Routing DSL.</li>\n</ul>\n<p>I will set up a simple HTTP server step by step, which in the end works as follows. As you see below, we get different JSON returned dependent on the path.</p>\n<img src="/blog/high-level-api-792c91bb20b6c2f1c281c0280dff73af.gif" />\n<p>I will go through the steps in a way you can <strong>quickly understand</strong> the outcome from running the source code, and how it works, <strong>WITHOUT downloading and running the source code yourself.</strong></p>\n<p>However, for those who want to go much deeper, the full code is available here, with instruction to run the examples.</p>\n<p><a href="https://github.com/richardimaoka/resources/tree/master/akka-http-quickstart">Jump to the Git repository with an intruction to run the code</a></p>\n<h2>Setting up a minimal application</h2>\n<p>In this section, we set up a pretty simple "Hello World" HTTP server. In the end, an Akka HTTP server can be started like below:</p>\n<pre><code class="language-scala">import akka.http.scaladsl.Http\nHttp().bindAndHandle(routes, "localhost", 8080)\n</code></pre>\n<p><img src="/blog/hello-world-54af7de2c758beb35a0e588cb6205572.gif" alt="hello-world"></p>\n<p>So, the <code>bindAndHandle</code> method is the method to fire up everything and start the HTTP server. Let\'s see what is required to run this <code>bindAndHandle</code> method.</p>\n<p>Firstly, we should update <a href="https://www.scala-sbt.org/1.x/docs/Library-Dependencies.html"><code>libraryDependencies</code></a> in <a href="https://github.com/richardimaoka/resources/blob/master/akka-http-quickstart/build.sbt">build.sbt</a></p>\n<pre><code>libraryDependencies ++= Seq(\n  "com.typesafe.akka" %% "akka-http"   % "10.1.3",\n  "com.typesafe.akka" %% "akka-stream" % "2.5.12",\n)\n</code></pre>\n<p>and add a <a href="https://www.scala-lang.org/documentation/your-first-lines-of-scala.html">typical main <code>object</code></a>, as well as its main method.</p>\n<pre><code class="language-scala">object MainHelloWorld {\n  def main(args: Array[String]): Unit = {\n    // ... application code goes here\n  }\n}\n</code></pre>\n<p>Inside the main method, we should start adding necessary building blocks to run the Akka HTTP server.</p>\n<pre><code class="language-scala">import akka.actor.ActorSystem\nimport akka.stream.ActorMaterializer\n\n// remember to make them implicit!!\nimplicit val system = ActorSystem("Main")       // for Akka Actor\nimplicit val materializer = ActorMaterializer() // for Akka Stream\n</code></pre>\n<p>As a preparation, we instantiate <code>ActorSystem</code> and <code>ActorMaterializer</code>. For people who are not familiar with <code>ActorSystem</code> and <code>ActorMaterializer</code>, you can think of them as the underlying infrastructure for running Akka HTTP.</p>\n<p>Usually there is only one instance for each of them in an entire application. In this context, an "entire application" means an OS (e.g. Linux or Windows) process, or a JVM process.  Also we need to remember making <code>ActorSystem</code> and <code>ActorMaterializer</code> <strong>implicit</strong>, as other methods take implicit parameters of these types.</p>\n<hr>\n<p><strong>NOTE:</strong> The below roughly illustrates the Akka technology stack cosisting of an Akka HTTP application.</p>\n<p align="center">\n  <img src="/blog/akka-layers-4cee9958d09be096686ab2ca6cff3612.svg" alt="akka-layers" width="300px"/>\n</p>\n<ul>\n<li>Akka HTTP is on top of the other two layers</li>\n<li>Akka Stream (<code>ActorMaterializer</code>) handles internal processing of Akka HTTP</li>\n<li>Akka Actor (<code>ActorSystem</code>) is the base for running Akka Stream</li>\n</ul>\n<p>In my upcoming articles, we will see how these layers work with each other, and see why and how Akka HTTP is designed as a <a href="https://doc.akka.io/docs/akka-http/current/implications-of-streaming-http-entity.html">"<strong>streaming-first</strong>" HTTP server</a>.</p>\n<hr>\n<p>The next thing to introduce is <code>Route</code>. <code>Route</code> in Akka HTTP defines the endpoint structure (or RESTful resource structure, we might say) of the HTTP server with <a href="https://doc.akka.io/docs/akka-http/current/routing-dsl/index.html">Route DSL</a>. Again, we only touch the surface of it in this article, and go deeper in later articles.</p>\n<pre><code class="language-scala">// importing akka...Directives._ makes `get` and `complete` avaialable in scope\nimport akka.http.scaladsl.server.Directives._ \nimport akka.http.scaladsl.server.Route\n\nlazy val routes: Route = get { // `get` for HTTP GET method\n  complete("Hello World")\n}\n</code></pre>\n<p><code>routes</code> in the above code returns <code>"Hello World"</code> for HTTP GET methods to any endpoint in the HTTP server. The <code>complete</code> method is what is typically used in Akka HTTP when we want to return an HTTP response to the client.</p>\n<p>Finally we can add the following code to bring up the HTTP server, like we saw at the begining of this section.</p>\n<pre><code class="language-scala">import akka.http.scaladsl.Http\nHttp().bindAndHandle(routes, "localhost", 8080)\n</code></pre>\n<p>Then run the server.</p>\n<pre><code>> sbt\n> runMain com.example.MainHelloWorld\n\n[info] Running com.example.Main\nServer online at http://localhost:8080/\n</code></pre>\n<p>And like we saw earlier in this section ...</p>\n<p><img src="/blog/hello-world-54af7de2c758beb35a0e588cb6205572.gif" alt="hello-world"></p>\n<p>Boom! We said hello to the world!</p>\n<h2>High-level Routing DSL to construct HTTP endpoint structure (RESTful resource structure)</h2>\n<p>We will go a little deeper in how Route DSL works. It is still at a surface level of it, but hopefully this gives you a better idea about how to construct the endpoint structure with the DSL.</p>\n<p>Assuming we want to have the following endpoint structure,</p>\n<pre><code>GET /users/person1\nGET /users/person2\nGET /users/person3\n</code></pre>\n<p>we can construct the route as follows:</p>\n<pre><code class="language-scala{6-7,9,11,14,19}">// importing akka...Directives._ makes `get`, `complete`, `path` avaialable\nimport akka.http.scaladsl.server.Directives._ \nimport akka.http.scaladsl.server.Route\n\nlazy val routes: Route = \n  pathPrefix("users") {\n    path("person1") {\n      get {\n        complete("Joh Don)\n      }\n    } ~ //don\'t forget `~`\n    path("person2") {\n      get {\n        complete("Justin Bieber")\n      }\n    } ~\n    path("person3") {\n      get {\n        complete("Peyton List")\n      }\n    } \n  }\n</code></pre>\n<p>Now, we get three different responses dependent on the path.</p>\n<p><img src="/blog/high-level-api-step1-3bd357ca49cce9b94a3269704f244dd3.gif" alt="high-level-step1"></p>\n<p>Since we set up these three endpoints for the HTTP <strong>GET</strong> method only,\ndoing (e.g.) POST will give us an error. </p>\n<pre><code>$ curl -X POST -d \'{"key": "value"}\' http://localhost:8080/users/person1\n\n// HTTP/1.1 405 Method Not Allowed\nHTTP method not allowed, supported methods: GET\n</code></pre>\n<p>Also, accessing a path which is not defined in the route will also result in an error.</p>\n<pre><code>$ curl http://localhost:8080/users/nosuchperson\n\n// HTTP/1.1 404 Not Found\nThe requested resource could not be found.\n</code></pre>\n<p>In a separate article, we go over details about the Route DSL, and introduce how to:</p>\n<ul>\n<li>support POST, PATCH, DELETE and even custom HTTP methods</li>\n<li>authenticate the user</li>\n<li>do more complicated stuff like CORS with plugins</li>\n<li>and lot more!</li>\n</ul>\n<h2>JSON to/from Scala case class conversion</h2>\n<p>Just returning plain <code>String</code> values to user is nothing interesting.\nAkka HTTP is well suited to API servers, and today\'s API servers most commonly interchanges JSON with clients.</p>\n<p><img src="/blog/high-level-api-792c91bb20b6c2f1c281c0280dff73af.gif" alt="high-level"></p>\n<p>In Akka HTTP, JSON support comes in a form of plugins, and <a href="https://github.com/spray/spray-json">spray-json</a>\nis one of the easiest JSON plugins to use, and also introduced in the official <a href="https://doc.akka.io/docs/akka-http/current/common/json-support.html">doc</a>.</p>\n<h3>Scala case class to JSON - HTTP response</h3>\n<p>In this article, we cover only one path - Scala case class to JSON conversion. The other way around, from JSON to Scala case classes should be covered in a separate article, to limit the length of this quick-start article.</p>\n<p>To use spray-json, we need the following in <code>libraryDependencies</code>.</p>\n<pre><code class="language-scala{4,5}">libraryDependencies ++= Seq(\n  "com.typesafe.akka" %% "akka-http"   % "10.1.3",\n  "com.typesafe.akka" %% "akka-stream" % "2.5.12",\n  "com.typesafe.akka" %% "akka-http-spray-json" % "10.1.3",\n  "io.spray" %%  "spray-json" % "1.3.4"\n)\n</code></pre>\n<p>And instead of returning a plain <code>String</code>,</p>\n<pre><code class="language-scala">get {\n  complete("Joh Don")\n}\n</code></pre>\n<p>we can pass in a Scala case class to the <code>complete</code> method,</p>\n<pre><code class="language-scala{4-7}">get {\n  complete(\n    // `User` is a Scala case class\n    User(\n      name = "Joh Don",\n      age = 35\n    )\n  )\n}\n</code></pre>\n<p>and it\'s magically turned into JSON within the HTTP response body.</p>\n<pre><code class="language-scala">// &#x3C;--------------- converted &#x3C;----------------\n// JSON                 | //Scala case class\n{                       |  User(\n  "name": "Joh Don",    |    name = "Joh Don",\n  "age":  35            |    age = 35 \n}                       |  )\n</code></pre>\n<p>So, what\'s necessary to make this magic happen? We need some type class-based\nimplicit resolution done by spray-json in conjunction with Akka HTTP.</p>\n<hr>\n<p><strong>Note</strong>: Understanding what\'s happening <strong>inside</strong> this <a href="https://doc.akka.io/docs/akka-http/current/common/marshalling.html">JSON to/from Scala case class conversion</a> is really, really a difficult thing. I personally gave it up more than five times in the past, by going through the official documentation, read the source code and ended up just wasting time.</p>\n<p>However, to make the JSON to/from Scala case class conversion happen, fortunately Akka HTTP is desined so that we <strong>don\'t need to</strong> understand what\'s happening inside. We just need to know what to <code>import</code> and what kind of <code>implicit</code> to define.</p>\n<p>If you are still interested in the internal workings, I\'ll write other articles to help you. I hope my articles I will write work as supplemental materials to the official doc if you felt that is not very easy to understand, like I did before.</p>\n<hr>\n<p>From here we see how to make the conversion happen. After updating <code>libraryDependencies</code> in <code>build.sbt</code>, we should introduce the following case class.</p>\n<pre><code class="language-scala">case class User(\n  name: String,\n  age:  Int\n)\n</code></pre>\n<p>This case class models the JSON in the HTTP response body, returned to the client. Then we add <code>implicit</code> <code>RootJsonFormat[User]</code> which is typically placed in the companion object of the modeling case class.</p>\n<pre><code class="language-scala{2-3,7-12}">//importing DefaultJsonProtocol._ makes `jsonFormat2` available\nimport spray.json.DefaultJsonProtocol._ \nimport spray.json.RootJsonFormat\n\ncase class User(name: String, age: Int)\n\nobject User {\n  // this will fit in the implicit resolution,\n  // enabling JSON/case class conversion\n  implicit val userJsonFormat: RootJsonFormat[User] =\n    jsonFormat2(User.apply)\n}\n</code></pre>\n<p><code>jsonFormat2</code> is a convenient method which takes the <code>apply</code> method of a two-value case class, and return <code>RootJsonFormat</code>. By using <code>jsonFormat2</code>, we don\'t need to implement field-by-field assignment manually like below.</p>\n<pre><code class="language-scala">// if we do not use a plugin like spray-json\nval json = ....\nUser(\n  // this field-by-field translation\n  // is NOT needed if we use `jsonFormat2`\n  name = json.getField("name").to[String],\n  age = json.getField("age").to[Int]\n)\n</code></pre>\n<p>Then on the <code>Route</code> side of the code, we need the following import and pass in a <code>User</code> instance to the <code>complete</code> method.</p>\n<pre><code class="language-scala{1-3,6}">import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\n//this bring in implicit RootJsonFormat[User]\nimport com.example.model.User\n\nget {\n  complete(User("Joh Don", 35))\n}\n</code></pre>\n<p>Importing these two will bring all the necessary pieces of implicit resolution, which works like putting pieces into the puzzle, and <code>User</code> can now be converted to JSON.</p>\n<p><img src="/blog/implicit-resolution-ed2b3779a41e22f8071c2c24413aee7d.jpg" alt="implicit resolution"></p>\n<p>We should do the same thing to the three paths we constructed before.</p>\n<pre><code class="language-scala{10,15,20}">import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\nimport akka.http.scaladsl.server.Directives._ \nimport akka.http.scaladsl.server.Route\nimport com.example.model.User\n\nlazy val routes: Route = \n  path("users/") {\n    path("person1"){\n      get {\n        complete(User(name = "Joh Don", age = 35))\n      }\n    } ~\n    path("person2"){\n      get {\n        complete(User(name = "Justin Bieber", age = 24))\n      }\n    } ~\n    path("person3"){\n      get {\n        complete((name = "Peyton List", age = 20))\n      }\n    }\n  }\n</code></pre>\n<p>And we can see this in action as follows.</p>\n<pre><code>> sbt\n> runMain com.example.main.MainHighLevelAPI\n</code></pre>\n<p><img src="/blog/high-level-api-complete-55cf956ed73ee75d743b703e7792cdb5.gif" alt="high-level-api-complete"></p>\n<h3>Nested case class support by spray-json</h3>\n<p>Another convenient feature of spray-json is (although other JSON plugins also have similar fetures) that it supports conversion of nested Scala case classes. Suppose we have the following two case classes defined.</p>\n<pre><code class="language-scala{5-10,15,21-22}">import spray.json.DefaultJsonProtocol.jsonFormat4\nimport spray.json.RootJsonFormat\n\ncase class Address(\n  zip:    Int,\n  street: String,\n  city:   String,\n  state:  String,\n)\n\nobject Address {\n  // this will fit in the implicit resolution,\n  // enabling JSON/case class conversion\n  implicit val addressJsonFormat: RootJsonFormat[Address] =\n    jsonFormat4(Address.apply)\n}\n</code></pre>\n<pre><code class="language-scala{3}">import spray.json.DefaultJsonProtocol.jsonFormat3\nimport spray.json.RootJsonFormat\nimport Address._ // implicit val addressJsonFormat\n\ncase class EnrichedUser(\n  name:    String,\n  age:     Int,\n  address: Address //nested case class\n)\n\nobject EnrichedUser {\n  // this will fit in the implicit resolution,\n  // enabling JSON/case class conversion\n  implicit val enrichedUserJsonFormat: RootJsonFormat[EnrichedUser] =\n    jsonFormat3(User.apply)\n}\n</code></pre>\n<p>And if we <code>complete</code> the route like below, </p>\n<pre><code class="language-scala{6-15}">import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\nimport com.example.model.User\n\nget {\n  complete(\n    EnrichedUser(\n      "Richard Imaoka",\n      150,\n      Address(\n        zip = 1112222,\n        street = "5-6-7 XYZ-street",\n        city = "New York",\n        state = "New York",\n      )\n    )\n  )\n}\n</code></pre>\n<p>we will get the following JSON.</p>\n<pre><code class="language-json{4-9}">{\n  "name": "Richard Imaoka",\n  "age": 150,\n  "address": {\n    "zip": 1112222,\n    "street" : "5-6-7 XYZ-street",\n    "city" : "New York",\n    "state" : "New York"     \n  }\n}\n</code></pre>\n<p>This helps us model the JSON data with reusable and <strong>composable</strong> Scala case classes, and will be useful when we are constructing a large JSON response.</p>\n<h2>Low-level API, needs understanding of HttpRequest and HttpResponse</h2>\n<p>Most of the cases we will be implementing our endpoint structure using the Route DSL.\nHowever, for certain cases we would need more fine-grained, lower-level control on how to respond to a given HTTP request. With the low-level API, instead of Route DSL, we implement a request handler in</p>\n<ul>\n<li><code>HttpRequest => HttpResponse</code>, or </li>\n<li><code>HttpRequest => Future[HttpResponse]</code> </li>\n</ul>\n<p>using pattern matches like below.</p>\n<pre><code class="language-scala">import akka.http.scaladsl.model.{HttpRequest, HttpResponse}\n\nval requestHandler: HttpRequest => HttpResponse = {\n  case HttpRequest(_, _, _, _, _) => HttpResponse(...)\n}    \n</code></pre>\n<p>That\'s roughly how the low level API looks differently from the high level one, then we get into a bit of more detail about this below. Like the case of high level API, we need to instantiate <code>ActorSystem</code> and <code>ActorMaterializer</code>.</p>\n<pre><code class="language-scala">import akka.actor.ActorSystem\nimport akka.stream.ActorMaterializer\n\nimplicit val system: ActorSystem = ActorSystem("Main")\nimplicit val materializer: ActorMaterializer = ActorMaterializer()\n</code></pre>\n<p>And the detail of the pattern match is as follows:</p>\n<pre><code class="language-scala{2,4-5,9,12-21}">import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\nimport akka.http.scaladsl.marshalling.Marshal\nimport akka.http.scaladsl.model.HttpMethods.GET\n// for HttpRequest, HttpResponse, Uri\nimport akka.http.scaladsl.model._\nimport com.example.model.User\nimport scala.concurrent.{ExecutionContext, Future}\n\nimplicit val ec: ExecutionContext = system.dispatcher\n\nval requestHandler: HttpRequest => Future[HttpResponse] = {\n  case HttpRequest(\n    GET,\n    Uri.Path("/"),\n    _, // matches any headers\n    _, // matches any HTTP entity (HTTP body)\n    _  // matches any HTTP protocol\n  ) => {\n    val m = Marshal(User("Richard Imaoka", 120))\n    m.to[HttpResponse]\n  }\n}\n</code></pre>\n<p>Then we can run the HTTP server like before,</p>\n<pre><code class="language-scala">import akka.http.scaladsl.Http\n\nHttp().bindAndHandleAsync(requestHandler, "localhost", 8080)\n</code></pre>\n<p>and we get this result.</p>\n<p><img src="/blog/low-level-api-ab0f421093d7a334cbaccbe40c4e3b36.png" alt="low-level-api"></p>\n<h2>The intention of this article</h2>\n<p>The content of this article might have felt boring to you, as there have already been many other articles covered the same stuff, and this is just like intro of introduction. </p>\n<p>However, I wrote this with a clear intention - I tried to make this article:</p>\n<ul>\n<li>Easy to see what happens upon running the code, without actually running it by hand</li>\n<li>Illustrate how it feels on writing Akka HTTP code, rather than explaining all the technical details</li>\n<li>but still not leaving readers in a gap, awkward jump in the context</li>\n<li>Have concise text, not talking endlessly about something readers are not interested</li>\n</ul>',frontmatter:{title:"Akka HTTP Quickstart",date:"July 15, 2018"}}},pathContext:{slug:"/akka-http-quickstart/"}}}});
//# sourceMappingURL=path---akka-http-quickstart-65f688c2d48558377460.js.map