webpackJsonp([0xd69bb118bf8e],{413:function(e,a){e.exports={data:{site:{siteMetadata:{title:"Akka, Concurrency, etc.",author:"Richard Imaoka"}},markdownRemark:{id:"C:/Users/richardimaoka/blog/src/pages/dispatcher-behavior/index.md absPath of file >>> MarkdownRemark",html:'<h2>Overview</h2>\n<iframe width="640" height="360" src="https://www.youtube.com/embed/0tDFep0hOSI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>\n<p>The concept of Akka <a href="https://doc.akka.io/docs/akka/2.5/dispatchers.html?language=scala"><code>Dispatcher</code></a> might be unfamiliar to you and it is probably difficult to understand. So I am going to explain how Dispatcher works in detail here.</p>\n<h2>Meaning of "dispatch"</h2>\n<p>If you look up the meaning of the word "dispatch" in a dictionary, you would find it is almost same as "send". In akka, <code>Dispatcher</code> is, yes, what sends messages, but something more than that.</p>\n<h2>Dispatcher and Actor relationship</h2>\n<p><img src="/blog/dispatcher-config-71bb79f013295f371bbb154394bc0b8e.jpg" alt="dispatcher-config"></p>\n<p>Firstly, <code>Dispatcher</code> is configured for <code>ActorSystem</code>, typically in <code>application.conf</code>. There is at least default one, and you can <a href="https://doc.akka.io/docs/akka/current/dispatchers.html#dispatchers">also configure multiple <code>Dispatcher</code>s</a>.</p>\n<pre><code class="language-scala">val system = ActorSystem("exampleSystem")\nsystem.dispatchers.lookup("my-dispatcher")\n</code></pre>\n<p>As a rule of thumb, the <code>Dispatcher</code> instance for the given name is created when the <a href="https://github.com/akka/akka/blob/v2.5.9/akka-actor/src/main/scala/akka/dispatch/Dispatchers.scala#L79"><code>lookup</code> method of <code>ActorSystem</code></a> is called for the first time. You don\'t normally call it yourself, but this lookup is done by akka. Another thing is the default <code>Dispatcher</code> is already created upon <code>ActorSystem</code> initialization, as it calls <code>lookup</code> for the default internally.</p>\n<pre><code class="language-scala">/**\n* Returns a dispatcher as specified in configuration. Please note that this\n* method _may_ create and return a NEW dispatcher, _every_ call.\n*\n* Throws ConfigurationException if the specified dispatcher cannot be found in the configuration.\n*/\ndef lookup(id: String): MessageDispatcher = lookupConfigurator(id).dispatcher()\n</code></pre>\n<p><img src="/blog/dispatcher-actor-7b6a80fb086b1889109bdb71e0f6f72f.jpg" alt="dispatcher-actor"></p>\n<p><code>Dispatcher</code> is NOT part of <code>Actor</code>. One <code>Dispatcher</code> can send messages to multiple <code>Actor</code>s. (NOTE: <code>Dispatcher</code> doesn\'t have routing capabilities. Routing is done by akka <a href="https://doc.akka.io/docs/akka/2.5/routing.html#routing"><code>Router</code></a>)</p>\n<h2>Dispatcher and ExecutorService</h2>\n<p><img src="/blog/dispatcher-executor-service-35308dce71584aa4d7cdfad5c6d455dd.jpg" alt="dispatcher-executor-service"></p>\n<p><code>Dispatcher</code> has <code>ExecutorService</code>, and <code>ExecutorService</code> is like a pool of threads where you can execute code (<code>Runnable</code>) concurrently. See <a href="../executor-and-execution-context">Executor/ExecutorService in Java, and ExecutionContext behind Future in Scala</a> for illustration and more details.</p>\n<p>Here is <a href="https://github.com/akka/akka/blob/v2.5.9/akka-actor/src/main/scala/akka/dispatch/Dispatcher.scala#L47"><code>executorService</code> method</a> of <code>Dispatcher</code>.</p>\n<pre><code class="language-scala">def executorService: ExecutorServiceDelegate = ...\n</code></pre>\n<p>The pool of threads from <code>ExecutorService</code> is what invokes <code>Actor</code>\'s <code>receive</code> method, which will be explained later in this article.</p>\n<h2>Dispatcher and sender-side behavior</h2>\n<p><img src="/blog/actor-cell-reference-6638f57fa06f7a2f08d0bd841a7eb514.jpg" alt="actor-cell-reference"></p>\n<p>Part of below is reharsing what was already discussed in <a href="../local-minimal-sender">Local Actor workflow part 1 - Sender side</a>, but here more from the <code>Dispatcher</code> perspective. </p>\n<p>(For remoting, there are several more steps to go through but it is combination of local message-passing and network via Netty, as discussed in <a href="../remote-minimal-sender">remoting articles</a>)</p>\n<p><code>LocalActorRef</code> is <a href="https://github.com/akka/akka/blob/v2.5.9/akka-actor/src/main/scala/akka/actor/ActorRef.scala#L319">coupled with <code>ActorCell</code></a>, which is hidden from users as private and it is implementation details of how akka messaging works.</p>\n<pre><code class="language-scala">class LocalActorRef(...)\n extends ActorRefWithCell\n with LocalRef  {\n  ...\n  val actorCell: ActorCell = ...\n  ...\n}\n</code></pre>\n<p><a href="">As you see below</a>, <code>ActorCell</code> has a reference to <code>Dispatcher</code> (<code>val dispatcher: MessageDispatcher</code>).</p>\n<pre><code class="language-scala">class ActorCell(\n  ...\n  val dispatcher:  MessageDispatcher,\n  ...\n  ) extends ...\n  ...\n  with dungeon.Dispatch {\n    ...\n  }\n</code></pre>\n<p>So when you do <code>actorRef ! "hello"</code>, that <code>actorRef</code> (whose type is <code>LocalActorRef</code>) already knows what <code>Dispatcher</code> to use via <a href="https://github.com/akka/akka/blob/v2.5.9/akka-actor/src/main/scala/akka/actor/ActorCell.scala#L370"><code>ActorCell</code></a>.</p>\n<p>Also <code>ActorCell</code> extends <a href="https://github.com/akka/akka/blob/v2.5.9/akka-actor/src/main/scala/akka/actor/dungeon/Dispatch.scala#L27"><code>Dispatch</code> trait</a> and it has a refence to <code>Mailbox</code>, so <code>LocalActorRef</code> also knows which <code>Mailbox</code> to send the massage, via <code>ActorCell</code>. </p>\n<pre><code class="language-scala">trait Dispatch { this: ActorCell â‡’\n  ...\n  def mailbox: Mailbox = ...\n  ...\n}\n</code></pre>\n<p>This couping of <code>LocalActorRef</code>, <code>ActorCell</code>, and <code>Mailbox</code> is what I meant by <code>Dispatcher</code> doesn\'t have routing capabilities in a "NOTE" earlier.</p>\n<p><img src="/blog/sender-82d6c008ac87adf2e72a0389eab07010.jpg" alt="sender"></p>\n<p><code>Dispatcher</code>\'s <a href="https://github.com/akka/akka/blob/v2.5.9/akka-actor/src/main/scala/akka/dispatch/Dispatcher.scala#L52L56">dispatch</a> method is as follows:</p>\n<pre><code class="language-scala">def dispatch(\n  receiver: ActorCell,\n  invocation: Envelope\n): Unit = {\n  val mbox = receiver.mailbox\n  mbox.enqueue(receiver.self, invocation)\n  registerForExecution(mbox, true, false)\n}\n</code></pre>\n<p>where <a href="https://github.com/akka/akka/blob/v2.5.9/akka-actor/src/main/scala/akka/dispatch/Dispatcher.scala#L115">registerForExecution</a> is:</p>\n<pre><code class="language-scala">def registerForExecution(mbox: Mailbox, ...): Boolean = {\n  ...\n  executorService execute mbox\n  ...\n}\n</code></pre>\n<p>In the above code, <code>Dispatcher</code>\'s <code>excutorService</code> is executing <code>mbox: Mailbox</code>, because <a href="https://github.com/akka/akka/blob/v2.5.9/akka-actor/src/main/scala/akka/dispatch/Mailbox.scala#L56L57"><code>Mailbox</code></a> extends <code>ForkJoinTask</code>, which can be <code>execute</code>-d by <code>ExecutorService</code>.</p>\n<p><img src="/blog/fork-join-1-a6354b55480d0404f2a1e8cc8cf61656.jpg" alt="fork-join-1"></p>\n<p><img src="/blog/fork-join-2-05d3f1320821da8a2108754cfb8375e2.jpg" alt="fork-join-2"></p>\n<pre><code class="language-scala">abstract class Mailbox(val messageQueue: MessageQueue)\n  extends ForkJoinTask[Unit] \n  with SystemMessageQueue \n  with Runnable {\n    ...\n}\n</code></pre>\n<p>Execution (i.e. processing) of <code>Mailbox</code> is run on a different <code>Thread</code>, which was covered in <a href="../local-minimal-receiver">Local Actor workflow part 2 - Receiver side</a></p>\n<h2>Dispatcher and receiver-side behavior</h2>\n<p><img src="/blog/fork-join-3-b8aff16a96f1775898c83f3ca43c0658.jpg" alt="fork-join-3"></p>\n<p>When <code>run</code> method of <code>ForkJoinTask</code> is executed, the <a href="https://github.com/akka/akka/blob/v2.5.9/akka-actor/src/main/scala/akka/dispatch/Mailbox.scala#L250">following method of <code>Mailbox</code></a> is called, </p>\n<pre><code class="language-scala">@tailrec private final def processMailbox(\n  ...\n  // def dequeue(): Envelope = messageQueue.dequeue()\n  val next = dequeue() \n  ...\n  actor invoke next\n  ...\n  processMailbox(...)\n}\n</code></pre>\n<p>it picks up a message from the message queue, and process it.</p>\n<p><img src="/blog/receiver-80a6300d25cf7552f05cceef167e99a5.jpg" alt="receiver"></p>\n<p>So this <code>processMailbox</code> method, called from <code>ForkJoinTask</code>\'s <code>run</code> is what invokes your <code>receive</code> method you defined in your <code>Actor</code>.</p>\n<pre><code class="language-scala">class MyActor extends Actor {\n  def receive = {\n    ...  \n  }  \n}\n</code></pre>',frontmatter:{title:"Dispatcher behavior",date:"February 12, 2018"}}},pathContext:{slug:"/dispatcher-behavior/"}}}});
//# sourceMappingURL=path---dispatcher-behavior-e43175dd21f98148787b.js.map