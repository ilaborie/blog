webpackJsonp([0xbac349952546],{416:function(e,t){e.exports={data:{site:{siteMetadata:{title:"Akka, Concurrency, etc.",author:"Richard Imaoka"}},markdownRemark:{id:"C:/Users/richardimaoka/blog/src/pages/hello-world-http-bench/index.md absPath of file >>> MarkdownRemark",html:'<h2>Overview</h2>\n<p>TL;DR) Benchmarking Akka HTTP and Spray "Hello World" servers did not discover significant performance difference.</p>\n<ul>\n<li>On Macbook, with Intel CPU Core i5 2.6GHz 2 cores</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align="left">Attempt</th>\n<th align="right">Akka HTTP</th>\n<th align="center">Spray</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">1st attempt</td>\n<td align="right">34,494 req/sec</td>\n<td align="center">37,005 req/sec</td>\n</tr>\n<tr>\n<td align="left">2nd attempt</td>\n<td align="right">41,469 req/sec</td>\n<td align="center">41,586 req/sec</td>\n</tr>\n<tr>\n<td align="left">3rd attempt</td>\n<td align="right">41,535 req/sec</td>\n<td align="center">42,438 req/sec</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>On Windows, with Intel CPU Core i7-6700 3.4GHz 4 cores/8 threads</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align="left">Attempt</th>\n<th align="right">Akka HTTP</th>\n<th align="center">Spray</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">1st attempt</td>\n<td align="right">75,439 req/sec</td>\n<td align="center">80,108 req/sec</td>\n</tr>\n<tr>\n<td align="left">2nd attempt</td>\n<td align="right">80,106 req/sec</td>\n<td align="center">80,453 req/sec</td>\n</tr>\n<tr>\n<td align="left">3rd attempt</td>\n<td align="right">79,608 req/sec</td>\n<td align="center">84,446 req/sec</td>\n</tr>\n</tbody>\n</table>\n<h2>Motivation</h2>\n<p>I am planning to write up articles analyzing Akka HTTP performance going forward, (probably about Akka internals too) so wanted to get familiar with tooling and procedure.</p>\n<p>So this very first article is pretty "rough", but still this gives me an insight about Akka HTTP\'s performance relative to Spray. I was interested in this relative performance analysis because one of Akka HTTP\'s performance goals was to catch up with Spray\'s performance.</p>\n<p>If you are conducting a serious performance analysis, you would not take benchmark in this way, as my "Hello World" server was too simple and I only used a single machine to run the server and the client, which hides whether the bottleneck was on the client or the server.</p>\n<h2>References</h2>\n<h3>akka-user discussion</h3>\n<p>There is a similiar discussion about Akka HTTP performance in the <a href="https://groups.google.com/forum/#!topic/akka-user/qhZlh0KBl2A">akka-user mailing list</a>, where the benchmark was taken using a tool called <a href="https://github.com/wg/wrk">wrk</a> against a simple serve doing hell-world json marshalling.</p>\n<blockquote>\n<p>Whereas for the Akka HTTP version I saw each core using ~40% CPU throughout the test and I had the following results:\n...</p>\n</blockquote>\n<pre><code>  2 threads and 100 connections\n  Thread calibration: mean lat.: 5.044ms, rate sampling interval: 10ms\n  Thread calibration: mean lat.: 5.308ms, rate sampling interval: 10ms\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.83ms    1.27ms  78.91ms   95.96%\n    Req/Sec    10.55k     1.79k   28.22k    75.98%\n  5997552 requests in 5.00m, 1.00GB read\nRequests/sec:  19991.72\nTransfer/sec:      3.41MB\n</code></pre>\n<p>The number I foncus on this time, was <strong>req/sec: 19991.72</strong>. Of course we have to look at various characteristics of performance in more serious analsys, but this is just a starting point for now.</p>\n<h3>Spray team blog</h3>\n<p><img src="/blog/spray-bench-528d4a6d6788732badde292e0479e2a5.png" alt="spray bench"></p>\n<p>Also there is a <a href="http://spray.io/blog/2013-05-24-benchmarking-spray/">Spray team blog entry</a> which shows its performance. As it says the benchmark server was doing JSON serialization without db access, it was probably similar to the above akka-user discussion.</p>\n<p>The req/sec was 33.8K in Spray but 19.9K in Akka HTTP. So my question was,\n"<strong>how do they perform on the same machine, doing the same thing?</strong>"</p>\n<p>Maybe the difference in their performance was due to the difference on the machines the benchmark was run, and probably because the code of one experiment was bit more complicated than the other.</p>\n<h2>My Bencmarking setup</h2>\n<p>I set up a very, very simple HTTP server in both in Akka HTTP and Spray, where the Spray one was inspired by its <a href="https://github.com/spray/spray-template">official template</a>.</p>\n<h3>Akka HTTP</h3>\n<p><a href="https://github.com/richardimaoka/resources/tree/master/akka-http-minimal">full code here</a> </p>\n<pre><code class="language-scala">import java.io.{PrintWriter, StringWriter}\n\nimport akka.actor.ActorSystem\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.server.Directives._\nimport akka.http.scaladsl.server.Route\nimport akka.stream.ActorMaterializer\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration.Duration\n\nobject HttpServer extends {\n  def main(args: Array[String]): Unit = {\n    implicit val system: ActorSystem = ActorSystem("HttpServer")\n    implicit val materializer: ActorMaterializer = ActorMaterializer()\n\n    lazy val routes: Route =\n      pathEndOrSingleSlash {\n        complete("Hello World")\n      }\n\n    Http().bindAndHandle(routes, "localhost", 8088)\n    println(s"Server online at http://localhost:8088/")\n    Await.result(system.whenTerminated, Duration.Inf)\n  }\n}\n</code></pre>\n<h3>Spray</h3>\n<p><a href="https://github.com/richardimaoka/resources/tree/master/spray-minimal">full code here</a></p>\n<pre><code class="language-scala">import akka.actor.{Actor, ActorSystem, Props}\nimport akka.io.IO\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport spray.can.Http\nimport spray.routing.HttpService\n\nimport scala.concurrent.duration._\n\n// this trait defines our service behavior independently from the service actor\ntrait MyService extends HttpService {\n  val myRoute =\n    path("") {\n      complete("Hello World")\n    }\n}\n\n// we don\'t implement our route structure directly in the service actor because\n// we want to be able to test it independently, without having to spin up an actor\nclass MyServiceActor extends Actor with MyService {\n\n  // the HttpService trait defines only one abstract member, which\n  // connects the services environment to the enclosing actor or test\n  def actorRefFactory = context\n\n  // this actor only runs our route, but you could add\n  // other things here, like request stream processing\n  // or timeout handling\n  def receive = runRoute(myRoute)\n}\n\n\nobject HttpServer {\n  def main(args: Array[String]): Unit = {\n    // we need an ActorSystem to host our application in\n    implicit val system = ActorSystem("on-spray-can")\n\n    // create and start our service actor\n    val service = system.actorOf(Props[MyServiceActor], "demo-service")\n\n    implicit val timeout = Timeout(5.seconds)\n    // start a new HTTP server on port 8090 with our service actor as the handler\n    IO(Http) ? Http.Bind(service, interface = "localhost", port = 8090)\n  }\n}\n</code></pre>\n<h3>Benchmarking method in detail</h3>\n<p>Same as the akka-user discussion, I used <a href="https://github.com/wg/wrk">wrk</a> to test the servers. On my Macbook (with Intel CPU Core i5 2.6GHz 2 cores), and got the following results for req/sec. This is the same table as I pasted at the beginning of the article. </p>\n<p>The reason I tried 3 attempts each was that due to JVM\'s JIT (Just-in-time) compilation, the frist and probably second attemps might not be at at the possible best performance. </p>\n<table>\n<thead>\n<tr>\n<th align="left">Attempt</th>\n<th align="right">Akka HTTP</th>\n<th align="center">Spray</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">1st attempt</td>\n<td align="right">34,494 req/sec</td>\n<td align="center">37,005 req/sec</td>\n</tr>\n<tr>\n<td align="left">2nd attempt</td>\n<td align="right">41,469 req/sec</td>\n<td align="center">41,586 req/sec</td>\n</tr>\n<tr>\n<td align="left">3rd attempt</td>\n<td align="right">41,535 req/sec</td>\n<td align="center">42,438 req/sec</td>\n</tr>\n</tbody>\n</table>\n<p>Taking more detailed results from the 3rd attempts, for <strong>Akka HTTP</strong>:</p>\n<pre><code>> wrk -t2 -c100 -d30s http://127.0.0.1:8088\nRunning 30s test @ http://127.0.0.1:8088\n  2 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     3.88ms   18.33ms 485.74ms   97.91%\n    Req/Sec    21.02k     4.59k   35.18k    82.57%\n  1248199 requests in 30.05s, 184.51MB read\nRequests/sec:  41535.58\nTransfer/sec:      6.14MB\n</code></pre>\n<p>and for <strong>Spray</strong>:</p>\n<pre><code>> wrk -t2 -c100 -d30s http://127.0.0.1:8090\nRunning 30s test @ http://127.0.0.1:8090\n  2 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     3.98ms   11.38ms 163.62ms   94.70%\n    Req/Sec    21.60k     5.89k   48.67k    77.40%\n  1273545 requests in 30.01s, 185.83MB read\nRequests/sec:  42438.22\nTransfer/sec:      6.19MB\n</code></pre>\n<p>They look like performing in a similar level. </p>\n<p>Then I did the same thing on my Windows machine as well (with Intel CPU Core i7-6700 3.4GHz 4 cores/8 threads), and results were as follows:</p>\n<table>\n<thead>\n<tr>\n<th align="left">Attempt</th>\n<th align="right">Akka HTTP</th>\n<th align="center">Spray</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">1st attempt</td>\n<td align="right">75,439 req/sec</td>\n<td align="center">80,108 req/sec</td>\n</tr>\n<tr>\n<td align="left">2nd attempt</td>\n<td align="right">80,106 req/sec</td>\n<td align="center">80,453 req/sec</td>\n</tr>\n<tr>\n<td align="left">3rd attempt</td>\n<td align="right">79,608 req/sec</td>\n<td align="center">84,446 req/sec</td>\n</tr>\n</tbody>\n</table>\n<p>Detailed results from the 3rd attempt for <strong>Akka HTTP</strong>,</p>\n<pre><code>> wrk -t2 -c100 -d30s http://127.0.0.1:8095/\nRunning 30s test @ http://127.0.0.1:8095/\n  2 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.46ms    6.53ms 260.11ms   98.93%\n    Req/Sec     40.08k    6.85k   59.53k    64.67%\n  2395691 requests in 30.09s, 354.13MB read\nRequests/sec:  79608.66\nTransfer/sec:     11.77MB\n</code></pre>\n<p>and for <strong>Spray</strong>, and these also gave similar perforamance.</p>\n<pre><code>> wrk -t2 -c100 -d30s http://127.0.0.1:8093/\nRunning 30s test @ http://127.0.0.1:8093/\n  2 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.18ms    2.68ms  61.62ms   98.26%\n    Req/Sec    42.55k     8.20k   61.00k    61.10%\n  2542858 requests in 30.11s, 371.03MB read\nRequests/sec:  84446.09\nTransfer/sec:     12.32MB\n</code></pre>\n<p>Here\'s the CPU usage profile on Windows at one point running the benchmark. The "Java" one is the Akka HTTP server. </p>\n<p><img src="/blog/win-cpu-utilization-8606513a030db443d74a33bdfdd8810d.png" alt="win-cpu-utilization"></p>\n<p>In a realistic situation where you, typically need to read and write to and from databases, etc, your web server won\'t be using CPU up to 100%, but network/database I/O tend to be bottlenecks. </p>\n<p>For now the experiment in this article tells us how the server behaves in the best possible situation where the CPU becomes the bottleneck.</p>\n<h2>Lessons learned and plans going forward ...</h2>\n<p>Just don\'t rely on these results and assume like "Akka HTTP and Spray can perform at this level!".</p>\n<p>As you saw here, benchmark results could significantly vary based on machines you run the bench. We have to keep in mind that the benchmark results are specific to the setup, including machines you run the bench, the server implementation and what kind of work the server does, latency and throughput between components if there are multiple components involved, etc.</p>\n<p>Also, what "realistic" benchmark actually means depends on what your target application (web server) is. We have to pay attention that the difference between application\'s production environment and the benchmark environment.</p>\n<p>Although having realistic setup, close to your production environment is important, another thing to note is that there is no one-size-fits-all benchmark method. Like anything else in software engineering, you should have differnt tooling for different aspects of benchmarking. You might think that if you make the benchmark environment as close as your production environment, you will get the most accurate results and that\'s it. However, that way, you cannot identify which component is the bottleneck of the performance when you see your entire application\'s performance is not satisfactory. You need more granular results from different parts of the system.</p>\n<p>That is why I did this very simple, ridiculously simple benchmarking. This didn\'t give us any realistic performance figure which we can guess the production performance from, but it gave me a sense on maximum possible performance of Akka HTTP web server. (Actually, better experiment is to run the client and the server on different machines though.)</p>\n<p>By testing each component individually, also testing in small groups of components, you will then realize the performance cap of each part of your entire application. Comparing that with your benchmark agains the whole application system, you will be able to figure out what is the bottleneck, and what part of the application is not scaling as you would have expected.</p>\n<p>So I am going to write up other articles to cover these aspects to show procedure on performing (web) application performance testing, and hopefully micro benchmarking internals of akka application/service too.</p>',frontmatter:{title:"Benchmarking Spray and Akka HTTP Hello World servers",date:"March 03, 2018"}}},pathContext:{slug:"/hello-world-http-bench/"}}}});
//# sourceMappingURL=path---hello-world-http-bench-35da9d029fe5bdfb8576.js.map