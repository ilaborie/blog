webpackJsonp([0xe77d7977c248],{417:function(a,s){a.exports={data:{site:{siteMetadata:{title:"Akka, Concurrency, etc.",author:"Richard Imaoka"}},markdownRemark:{id:"C:/Users/richardimaoka/blog/src/pages/akka-future-promise-actor-ref/index.md absPath of file >>> MarkdownRemark",html:'<p><img src="/blog/promise-actor-ref-49f29933907fc880690c787b601a6062.gif"></p>\n<p>I’m writing this article because I wanted to share my little findings about Akka ask pattern’s internal behavior, which are the use of <code class="language-text">PromiseActorRef</code>.</p>\n<p>While doing some experiments in Akka, I came up with a question about how the Akka ask pattern distinguishes multiple messages returned back in a random order from the target actor, and it turned out the answer was <code class="language-text">PromiseActorRef</code>.</p>\n<h2>Review of the Akka ask pattern, which uses the <code class="language-text">?</code> method.</h2>\n<p>The Akka ask pattern is described <a href="https://github.com/akka/akka/blob/v2.5.14/akka-actor/src/main/scala/akka/pattern/AskSupport.scala">here in the official documentation</a>, but we also review it here. You can skip this section if you are already familiar with it.</p>\n<p>In Akka, there are basically two patterns to send a message betwen actors. The first is the <strong>tell pattern</strong>, which uses the <code class="language-text">!</code> method.</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala">actor <span class="token operator">!</span> message</code></pre>\n      </div>\n<p>This is the <strong>fire-and-forget</strong> style for sending a message, and used more prevalently than the other pattern in Akka-based applications.</p>\n<p>The other pattern is called the <strong>ask pattern</strong>, which uses the <code class="language-text">?</code> method to send a message and waits until there is a returning message back from the target <code class="language-text">actor</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token keyword">import</span> akka<span class="token punctuation">.</span>pattern<span class="token punctuation">.</span>ask\n<span class="token keyword">val</span> fut<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> actor <span class="token operator">?</span> message</code></pre>\n      </div>\n<p>The return type of the <code class="language-text">?</code> method is <code class="language-text">Future</code> so that the caller thread of the <code class="language-text">?</code> method is not blocked, and upon target <code class="language-text">actor</code> returning the resulting message to the sender, the <code class="language-text">Future</code> is completed. </p>\n<p>Supplying necessary imports and declarations, the code looks like this:</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="gatsby-highlight-code-line"><span class="token keyword">import</span> akka<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>ActorRef\n</span><span class="token keyword">import</span> akka<span class="token punctuation">.</span>pattern<span class="token punctuation">.</span>ask\n<span class="gatsby-highlight-code-line"><span class="token keyword">import</span> scala<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future\n</span><span class="gatsby-highlight-code-line"><span class="token keyword">import</span> scala<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>duration<span class="token punctuation">.</span>_\n</span><span class="gatsby-highlight-code-line">\n</span><span class="gatsby-highlight-code-line"><span class="token keyword">val</span> actor<span class="token operator">:</span> ActorRef <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n</span><span class="gatsby-highlight-code-line"><span class="token keyword">val</span> message <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n</span><span class="gatsby-highlight-code-line">\n</span><span class="gatsby-highlight-code-line"><span class="token keyword">implicit</span> ec<span class="token operator">:</span> ExecutionContext <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n</span><span class="gatsby-highlight-code-line"><span class="token keyword">implicit</span> timeout<span class="token operator">:</span> Timeout <span class="token operator">=</span> <span class="token number">10.</span>seconds\n</span><span class="token keyword">val</span> fut<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> actor <span class="token operator">?</span> message</code></pre>\n      </div>\n<p>and if you do this inside an <code class="language-text">Actor</code>, it is done as follows:</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="gatsby-highlight-code-line"><span class="token keyword">import</span> akka<span class="token punctuation">.</span>actor<span class="token punctuation">.</span><span class="token punctuation">{</span>Actor<span class="token punctuation">,</span> ActorRef<span class="token punctuation">}</span>\n</span><span class="token keyword">import</span> akka<span class="token punctuation">.</span>pattern<span class="token punctuation">.</span>ask\n<span class="token keyword">import</span> scala<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future\n<span class="token keyword">import</span> scala<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>duration<span class="token punctuation">.</span>_\n\n<span class="gatsby-highlight-code-line"><span class="token keyword">class</span> SenderActor <span class="token keyword">extends</span> Actor <span class="token punctuation">{</span>\n</span>  <span class="token keyword">val</span> actor<span class="token operator">:</span> ActorRef <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n\n<span class="gatsby-highlight-code-line">  <span class="token keyword">def</span> receive <span class="token operator">=</span> <span class="token punctuation">{</span>\n</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n    <span class="token keyword">val</span> message <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n  \n    <span class="token keyword">implicit</span> ec<span class="token operator">:</span>ExecutionContext <span class="token operator">=</span> context<span class="token punctuation">.</span>dispatcher\n    <span class="token keyword">implicit</span> timeout<span class="token operator">:</span> Timeout <span class="token operator">=</span> <span class="token number">10.</span>seconds\n    <span class="token keyword">val</span> fut<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> actor <span class="token operator">?</span> message\n    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span>\n</span><span class="gatsby-highlight-code-line"><span class="token punctuation">}</span>\n</span></code></pre>\n      </div>\n<p><img src="/blog/ask-as-message-passing-6f831b2e15abe1d89e23f4eaa8f2b0ac.png"></p>\n<p>Under the hood, this <code class="language-text">?</code> method invocation is implemented by Akka’s message passing. So, what’s the big deal about this and why its internal (<code class="language-text">PromiseActorRef</code>) is interesting? To see that, let me introduce my question from the next section.</p>\n<h2>Invoking two <code class="language-text">Future</code>s by the <code class="language-text">?</code> (ask) method</h2>\n<p>Instead of just invonking the <code class="language-text">?</code> method once, let’s invoke the <code class="language-text">?</code> method for two different messages consecutively.</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token keyword">import</span> akka<span class="token punctuation">.</span>actor<span class="token punctuation">.</span><span class="token punctuation">{</span>Actor<span class="token punctuation">,</span> ActorRef<span class="token punctuation">}</span>\n<span class="token keyword">import</span> akka<span class="token punctuation">.</span>pattern<span class="token punctuation">.</span>ask\n<span class="token keyword">import</span> scala<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future\n\n<span class="token keyword">class</span> MyActor <span class="token keyword">extends</span> Actor <span class="token punctuation">{</span>\n  <span class="token keyword">val</span> actor<span class="token operator">:</span> ActorRef <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n\n  <span class="token keyword">def</span> receive <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n    <span class="token keyword">val</span> message <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n  \n    <span class="token keyword">implicit</span> ec<span class="token operator">:</span> ExecutionContext <span class="token operator">=</span> context<span class="token punctuation">.</span>dispatcher\n<span class="gatsby-highlight-code-line">    <span class="token comment">// What if the actor replies earlier for someMessage2 than someMessage1?</span>\n</span><span class="gatsby-highlight-code-line">    <span class="token keyword">val</span> fut1<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> actor <span class="token operator">?</span> message1\n</span><span class="gatsby-highlight-code-line">    <span class="token keyword">val</span> fut2<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> actor <span class="token operator">?</span> message2\n</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>The target <code class="language-text">Actor</code> can be like this, where it sends back the <code class="language-text">result</code> to the original <code class="language-text">sender</code> actor in the end.</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token keyword">class</span> TargetActor <span class="token keyword">extends</span> Actor <span class="token punctuation">{</span>\n  <span class="token keyword">import</span> TargetActor<span class="token punctuation">.</span>_\n  <span class="token keyword">def</span> someBackendOperation<span class="token punctuation">(</span>message<span class="token operator">:</span> Message<span class="token punctuation">)</span><span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span>\n    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// It might send messages to other actors,</span>\n        <span class="token comment">// or perform async database operations, etc</span>\n\n  <span class="token keyword">def</span> receive <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> message<span class="token operator">:</span> Message <span class="token keyword">=></span>\n<span class="gatsby-highlight-code-line">      <span class="token keyword">val</span> sender <span class="token operator">=</span> sender<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// sender is same for the two messages</span>\n</span>      <span class="token keyword">val</span> resultFuture <span class="token operator">=</span> someBackendOperation<span class="token punctuation">(</span>message<span class="token punctuation">)</span>\n      resultFuture<span class="token punctuation">.</span>onComplete <span class="token punctuation">{</span>\n<span class="gatsby-highlight-code-line">        <span class="token keyword">case</span> Success<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">=></span> sender <span class="token operator">!</span> result\n</span>        <span class="token keyword">case</span> Failure<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// error handling</span>\n      <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">object</span> TargetActor <span class="token punctuation">{</span>\n  <span class="token keyword">case</span> <span class="token keyword">class</span> Message<span class="token punctuation">(</span>body<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>The point is that, since the <code class="language-text">someBackendOperation</code> above, which probably sends a message to another actor, or perform some async database operations, etc, is asynchronous and take arbitrary amount of time, the returning message from <code class="language-text">TargetActor</code> to <code class="language-text">SenderActor</code> <strong>can be sent in a random order</strong>.</p>\n<p><img src="/blog/sent-order-a73a6f8c7f8e4d676bd340ad30324671.png">\n<img src="/blog/returned-order-e93d97dcee2d60b563d315efee5e4890.png"></p>\n<p>So, the <code class="language-text">fut2</code> can complete earlier than the <code class="language-text">fut1</code> below:</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token comment">// invoked earlier, but completed latter</span>\n<span class="token keyword">val</span> fut1<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> actor <span class="token operator">?</span> message1\n\n<span class="token comment">// invoked later, but completed earlier</span>\n<span class="token keyword">val</span> fut2<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> actor <span class="token operator">?</span> message2</code></pre>\n      </div>\n<p>then how the <code class="language-text">?</code> method distinguishes the return for the <code class="language-text">message2</code> from the <code class="language-text">message1</code>? If they are not distinguished, the return for the <code class="language-text">message2</code> completes the <code class="language-text">fut1</code> which is a total mess, but that does not happen. <strong>The <code class="language-text">?</code> method distinguishes return for each</strong> <code class="language-text">?</code> <strong>invocation</strong>.</p>\n<h2>PromiseActorRef comes into play</h2>\n<p>The secret for the above behavior is <code class="language-text">PromiseActorRef</code>, which is the key to distinguish returns for each <code class="language-text">?</code> method invocation. </p>\n<p><img src="/blog/promise-actor-ref1-fd876980a7078e3a103765a91e62237b.png"></p>\n<p>Although we gave the <code class="language-text">class SenderActor</code> name to the actor which invoked the <code class="language-text">?</code> method, precisely the real sender of the message is different.</p>\n<p>A <code class="language-text">PromiseActorRef</code> instance is the real sender of the message when you invoke the <code class="language-text">?</code> method in Akka, and the <code class="language-text">PromiseActorRef</code> instance is swapned off <strong>every time</strong> you call the <code class="language-text">?</code> method, so that the real sender of the message is different for each <code class="language-text">?</code> method invocation. (i.e.) for each <code class="language-text">?</code> method, the target actor returns to a different <code class="language-text">PromiseActorRef</code> instance.</p>\n<p>Indeed, the <code class="language-text">sender: ActorRef</code> parameter in the <code class="language-text">?</code> method signature is nothing to do with the real sender <a href="https://github.com/akka/akka/blob/v2.5.14/akka-actor/src/main/scala/akka/pattern/AskSupport.scala#L282">(code here)</a>:.</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token keyword">def</span> <span class="token operator">?</span><span class="token punctuation">(</span>\n  message<span class="token operator">:</span> <span class="token builtin">Any</span>\n<span class="token punctuation">)</span><span class="token punctuation">(</span>\n  <span class="token keyword">implicit</span> timeout<span class="token operator">:</span> Timeout<span class="token punctuation">,</span> sender<span class="token operator">:</span> ActorRef <span class="token operator">=</span> Actor<span class="token punctuation">.</span>noSender\n<span class="token punctuation">)</span><span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span>\n  internalAsk<span class="token punctuation">(</span>message<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> sender<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>The <code class="language-text">implicit sender</code> parameter is only used for error logging as follows, not used for anything else within the <code class="language-text">?</code> method  <a href="https://github.com/akka/akka/blob/v2.5.14/akka-actor/src/main/scala/akka/pattern/AskSupport.scala#L606">(code here)</a>:\n.</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala">onTimeout<span class="token punctuation">(</span>\n  s<span class="token string">"""Ask timed out on [$targetName]\n      | after [${timeout.duration.toMillis} ms].\n<span class="gatsby-highlight-code-line">      | Sender[$sender] sent message of type "${a.messageClassName}".\n</span>      | """</span><span class="token punctuation">.</span>stripMargin<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<hr>\n<p><strong>NOTE</strong>: And this also answers another interesting question about why you can invoke the <code class="language-text">?</code> method outside <code class="language-text">Actor</code>. As long as you supply necessary <code class="language-text">implicit ExecutionContext</code> and <code class="language-text">implicit Timeout</code>, you can do this, outside <code class="language-text">Actor</code>. </p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token keyword">import</span> akka<span class="token punctuation">.</span>actor<span class="token punctuation">.</span>ActorRef\n<span class="token keyword">import</span> akka<span class="token punctuation">.</span>pattern<span class="token punctuation">.</span>ask\n<span class="token keyword">import</span> scala<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future\n<span class="token keyword">import</span> scala<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>duration<span class="token punctuation">.</span>_\n\n<span class="token keyword">val</span> actor<span class="token operator">:</span> ActorRef <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token keyword">val</span> message <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n\n<span class="token keyword">implicit</span> ec<span class="token operator">:</span> ExecutionContext <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token keyword">implicit</span> timeout<span class="token operator">:</span> Timeout <span class="token operator">=</span> <span class="token number">10.</span>seconds\n<span class="token keyword">val</span> fut<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> actor <span class="token operator">?</span> message</code></pre>\n      </div>\n<p>The target <code class="language-text">actor</code> needs the <code class="language-text">sender</code> to send the result back, so unlike the <code class="language-text">!</code> (tell) pattern, <strong>there must be a real sender actor instance</strong>. <code class="language-text">PromiseActorRef</code> is used as the real sender, so it doesn’t matter whether you call the <code class="language-text">?</code> method inside or outside <code class="language-text">Actor</code>.</p>\n<hr>\n<p>Lastly, the below is the internal implementation of the ask pattern, which is called inside the <code class="language-text">?</code> method <a href="https://github.com/akka/akka/blob/v2.5.14/akka-actor/src/main/scala/akka/pattern/AskSupport.scala#L288">(code here)</a>:</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token comment">/**\n  * INTERNAL API: for binary compatibility\n  */</span>\n<span class="token keyword">private</span><span class="token punctuation">[</span>pattern<span class="token punctuation">]</span> <span class="token keyword">def</span> internalAsk<span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">Any</span><span class="token punctuation">,</span> timeout<span class="token operator">:</span> Timeout<span class="token punctuation">,</span> sender<span class="token operator">:</span> ActorRef<span class="token punctuation">)</span> <span class="token operator">=</span> actorRef <span class="token keyword">match</span> <span class="token punctuation">{</span>\n  <span class="token keyword">case</span> ref<span class="token operator">:</span> InternalActorRef <span class="token keyword">if</span> ref<span class="token punctuation">.</span>isTerminated ⇒\n    actorRef <span class="token operator">!</span> message\n    Future<span class="token punctuation">.</span>failed<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">new</span> AskTimeoutException<span class="token punctuation">(</span>s<span class="token string">"""Recipient[$actorRef] had already been terminated. Sender[$sender] sent the message of type "${message.getClass.getName}"."""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token keyword">case</span> ref<span class="token operator">:</span> InternalActorRef ⇒\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">.</span>duration<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>\n      Future<span class="token punctuation">.</span>failed<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">new</span> IllegalArgumentException<span class="token punctuation">(</span>s<span class="token string">"""Timeout length must be positive, question not sent to [$actorRef]. Sender[$sender] sent the message of type "${message.getClass.getName}"."""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token keyword">else</span> <span class="token punctuation">{</span>\n<span class="gatsby-highlight-code-line">      <span class="token keyword">val</span> a <span class="token operator">=</span> PromiseActorRef<span class="token punctuation">(</span>ref<span class="token punctuation">.</span>provider<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> targetName <span class="token operator">=</span> actorRef<span class="token punctuation">,</span> message<span class="token punctuation">.</span>getClass<span class="token punctuation">.</span>getName<span class="token punctuation">,</span> sender<span class="token punctuation">)</span>\n</span>      actorRef<span class="token punctuation">.</span>tell<span class="token punctuation">(</span>message<span class="token punctuation">,</span> a<span class="token punctuation">)</span>\n      a<span class="token punctuation">.</span>result<span class="token punctuation">.</span>future\n    <span class="token punctuation">}</span>\n  <span class="token keyword">case</span> _ ⇒ Future<span class="token punctuation">.</span>failed<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">new</span> IllegalArgumentException<span class="token punctuation">(</span>s<span class="token string">"""Unsupported recipient ActorRef type, question not sent to [$actorRef]. Sender[$sender] sent the message of type "${message.getClass.getName}"."""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>And as in the comment of <code class="language-text">PromiseActorRef</code>, it is optimized for this temporary use in the ask pattern. <a href="https://github.com/akka/akka/blob/v2.5.14/akka-actor/src/main/scala/akka/pattern/AskSupport.scala#L438">(code here)</a></p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"> <span class="token comment">/**\n * Akka private optimized representation of the temporary actor spawned to\n * receive the reply to an "ask" operation.\n *\n * INTERNAL API\n */</span>\n<span class="token keyword">private</span><span class="token punctuation">[</span>akka<span class="token punctuation">]</span> <span class="token keyword">final</span> <span class="token keyword">class</span> PromiseActorRef <span class="token keyword">private</span> <span class="token punctuation">(</span>\n  <span class="token keyword">val</span> provider<span class="token operator">:</span> ActorRefProvider<span class="token punctuation">,</span>\n  <span class="token keyword">val</span> result<span class="token operator">:</span> Promise<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token punctuation">,</span> _mcn<span class="token operator">:</span> <span class="token builtin">String</span>\n<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>Hope this was interesting for you as well, and made it clear that you don’t need to be afraid of the order of returning messages from the target to the sender, when using the Akka ask pattern.</p>',frontmatter:{title:"Akka actor's ask pattern and its internal PromiseActorRef",date:"August 04, 2018"}}},pathContext:{slug:"/akka-future-promise-actor-ref/"}}}});
//# sourceMappingURL=path---akka-future-promise-actor-ref-f7c5c2432ff4c679116c.js.map