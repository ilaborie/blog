webpackJsonp([0x6a237ceb57d4],{420:function(e,a){e.exports={data:{site:{siteMetadata:{title:"Akka, Concurrency, etc.",author:"Richard Imaoka"}},markdownRemark:{id:"C:/Users/richardimaoka/blog/src/pages/akka-http-operation-scope/index.md absPath of file >>> MarkdownRemark",html:'<p><img src="/blog/inscope-operation-97f164893d68c7401fef0d16b1ce0978.png">\n<img src="/blog/deferred-operation-fd557ebaab2939b6a5e52109d5b50e3d.png"></p>\n<p>If you are new to writing an HTTP server application in Akka HTTP, you might wonder how to implement the backend processing upon an HTTP request. </p>\n<p>I am going to give a basic guidance for this, with concepts I call as ”<strong>HTTP request/response scope operations</strong>” and ”<strong>Deferred operations</strong>”. The terminology is something I came up, not widely used, but hopefully it becomes clear as you read through the article.</p>\n<h3>Typical backend processing in Akka HTTP</h3>\n<p>A simplified but typical <code class="language-text">Route</code> handling an HTTP request for a certain end point is like this:</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token keyword">val</span> specificEndPoint<span class="token operator">:</span> Route <span class="token operator">=</span> path<span class="token punctuation">(</span><span class="token string">"path/to/endpoint"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  post <span class="token punctuation">{</span>\n    authorize<span class="token punctuation">(</span>customAuthorizationLogic<span class="token punctuation">)</span><span class="token punctuation">{</span> userInfo <span class="token keyword">=></span>\n      entity<span class="token punctuation">(</span>as<span class="token punctuation">[</span>BuyOrder<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> order <span class="token keyword">=></span>\n        <span class="token keyword">val</span> result<span class="token operator">:</span> Future<span class="token punctuation">[</span>OrderResult<span class="token punctuation">]</span> <span class="token operator">=</span>\n<span class="gatsby-highlight-code-line">          backendService<span class="token punctuation">.</span>processOrder<span class="token punctuation">(</span>order<span class="token punctuation">)</span>\n</span>        complete<span class="token punctuation">(</span>result<span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>And the signature of <code class="language-text">backendService.processOrder</code> can be:</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token keyword">class</span> BackendService <span class="token keyword">extends</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">{</span>\n  <span class="token keyword">def</span> processOrder<span class="token operator">:</span> Future<span class="token punctuation">[</span>OrderResult<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>It is very common that such backend service for Akka HTTP returns <code class="language-text">Future</code>, and pass that <code class="language-text">Future</code> to the <code class="language-text">complete</code> directive. Up to this point, there is not much to think about, but when we start implementing this <code class="language-text">processOrder</code> method, there are many choices as a lot of things can result in <code class="language-text">Future</code> in Scala: </p>\n<ul>\n<li>A database persistence call</li>\n<li>An external service call, typicall via HTTP</li>\n<li>Or a persistence to messaging queue</li>\n<li>The akka <a href="https://doc.akka.io/docs/akka/current/futures.html#use-with-actors">ask pattern</a> (<code class="language-text">?</code> method) sending messages to the backend Actor(s)</li>\n</ul>\n<p>The difference between “HTTP request/response scope operations” and “Deferred operations” is a key to deciding on properly implementing the backend operation.</p>\n<h2>HTTP request/response scope operations</h2>\n<p><img src="/blog/inscope-operation-97f164893d68c7401fef0d16b1ce0978.png"></p>\n<p>An HTTP request/response scope operation is performed inside the Akka HTTP Routing DSL, like <code class="language-text">backendService.processOrder</code> in the earlier example. </p>\n<p>It is important to note that the HTTP response is sent <strong>after</strong> the HTTP request/response scope operation is completed.</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token keyword">class</span> BackendService <span class="token keyword">extends</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">{</span>\n  <span class="token keyword">def</span> processOrder<span class="token operator">:</span> Future<span class="token punctuation">[</span>OrderResult<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n<span class="gatsby-highlight-code-line">    <span class="token comment">// Only **AFTER*** everything we performed here inside the method</span>\n</span><span class="gatsby-highlight-code-line">    <span class="token comment">// is finished, the HTTP response can be sent</span>\n</span>  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>As the <code class="language-text">complete</code> directive in Routing DSL can take <code class="language-text">Future</code> as its parameter, the directive waits until the <code class="language-text">Future</code> from the backend service is completed.</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala"><span class="token keyword">val</span> specificEndPoint<span class="token operator">:</span> Route <span class="token operator">=</span> path<span class="token punctuation">(</span><span class="token string">"path/to/endpoint"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  post <span class="token punctuation">{</span>\n    authorize<span class="token punctuation">(</span>customAuthorizationLogic<span class="token punctuation">)</span><span class="token punctuation">{</span> userInfo <span class="token keyword">=></span>\n      entity<span class="token punctuation">(</span>as<span class="token punctuation">[</span>BuyOrder<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> order <span class="token keyword">=></span>\n        <span class="token keyword">val</span> result<span class="token operator">:</span> Future<span class="token punctuation">[</span>OrderResult<span class="token punctuation">]</span> <span class="token operator">=</span>\n          backendService<span class="token punctuation">.</span>processOrder<span class="token punctuation">(</span>order<span class="token punctuation">)</span>\n<span class="gatsby-highlight-code-line">        complete<span class="token punctuation">(</span>result<span class="token punctuation">)</span>\n</span>      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>So there is guaranteed ordering - when the client receives the HTTP response, we can safely assume the backend operations for the request were finished. This is useful if the client sends further requests, after the initial request, and the backend needs to process the further requests based on the result from the initial request processing.</p>\n<p>Of course, ordering doesn’t necessarily guarantee operation’s success. So we should return an HTTP error response on an error case, and probably we also need some recovery logic upon backend service’s <code class="language-text">Future</code> failure.</p>\n<h3>Caveats on the Akka ask pattern</h3>\n<p><img src="/blog/actor-overwhelmed-b660aa8e2f47f2ef7101c1399e25a312.png"></p>\n<p>When we invoke the Akka <code class="language-text">?</code> method as the ask pattern, be careful on not overwhelming the <code class="language-text">backendActor</code> with a lot of messages.</p>\n<div class="gatsby-highlight">\n      <pre class="language-scala"><code class="language-scala">entity<span class="token punctuation">(</span>as<span class="token punctuation">[</span>BuyOrder<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> order <span class="token keyword">=></span>\n<span class="gatsby-highlight-code-line">  <span class="token keyword">val</span> result<span class="token operator">:</span> Future<span class="token punctuation">[</span>OrderResult<span class="token punctuation">]</span> <span class="token operator">=</span>\n</span><span class="gatsby-highlight-code-line">    <span class="token punctuation">(</span>backendActor <span class="token operator">?</span> BuyOrder<span class="token punctuation">)</span><span class="token punctuation">.</span>mapTo<span class="token punctuation">[</span>OrderResult<span class="token punctuation">]</span>\n</span>  complete<span class="token punctuation">(</span>result<span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>As explained in <a href="https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#controlling-server-parallelism">the official doc</a>, the number of TCP connections Akka HTTP can handle is defined in <code class="language-text">akka.http.server.max-connections</code> whose default is <code class="language-text">1024</code>.</p>\n<p>Akka HTTP is particularly designed to handle many connections steadily with low memry footprint, so chances are that there could be so many requests comming in at a volume spike, and if we only have one, or very low number of backend Actors, their Actor mailboxes will explode.</p>\n<h3>Latency matters in the HTTP request/response scope operations</h3>\n<p>As we have seen, the <code class="language-text">complete</code> directive waits until the <code class="language-text">Future</code> completes, then after that, sends the HTTP response back to the client.</p>\n<p>So, if we perform many operations inside the backend <code class="language-text">Future</code>, the HTTP response will be delayd and that’s bad for the client experience.</p>\n<p>In such a case, we should start thinking about what I call as “deferred opertions”.</p>\n<p>However, don’t jump to deferred operatoins when the latecy at an OK level. When we start doing deferred operations, we will lose guaranteed ordering like the explained above, so we need different approaches when we need ordering on certain operations.</p>\n<h2>Deferred operations, out of the scope from HTTP request/response</h2>\n<p><img src="/blog/deferred-operation-fd557ebaab2939b6a5e52109d5b50e3d.png"></p>\n<p>Deferred operations are something that can be performed even after the HTTP response is already sent back to the client. That means that, when the client sends the next request, we have no guarantee that all the backend operation for the former request were finished.</p>\n<p>On the other hand, since we skip some operations before sending back the HTTP response, the latency within HTTP request/response cycle can be improved.</p>\n<p>Remember that still we can perform some operations within the HTTP request/response scope, so using deferred operations means using <strong>the mix of request/response scope operations and deffered operations</strong>.</p>\n<p>When in that mixed mode, within the HTTP request/response scope, we usually put the msesages to the queue, so that the messages can be processed afterwards. Often message queue systems like Apache Kafka or RabbitMQ are used for that purpose.</p>\n<h3>Akka Streams in deffered operations</h3>\n<p><img src="/blog/deferred-stream-f0df14f1d0904aa068bd8e7c9f31d863.png"></p>\n<p>Running Akka Streams as the deferred operations is a good idea, especially when you have a durable message queue which Akka Streams can <code class="language-text">Source</code> the data from. </p>\n<p>As I explained <a href="https://richardimaoka.github.io/blog/akka-http-stream-integration/">in another article</a>, we won’t be able to integrate Akka Streams inside the Akka HTTP’s request/response scope, so deferred operations is a place where Akka Streams naturally fit.</p>\n<p>If you are interested and want to explore more on Akka Streams, I highly recommend visiting the <a href="https://developer.lightbend.com/docs/alpakka/current/">Alpakka project site</a>, as it gives you a wide variety of connectors including Cassandra, Kafka, AWS Lambda, S3, ElasticSearch, Files, GCP Pub/Sub, and a lot, lot more!!</p>\n<blockquote>\n<p><a href="https://github.com/akka/alpakka">https://github.com/akka/alpakka</a>: The Alpakka project is an open source initiative to implement stream-aware, reactive, integration pipelines for Java and Scala. It is built on top of Akka Streams, and has been designed from the ground up to understand streaming natively and provide a DSL for reactive and stream-oriented programming, with built-in support for backpressure.</p>\n</blockquote>\n<h3>Caution: Don’t use Akka Actor nor Akka Persistence as a messaging queue</h3>\n<p>When in the deffered operation mode (i.e. mix of request/response scode and deffered operations), there might be tendency to use Akka Actor as a message queue if it feels an overkill to set up a message queue like Kafka.</p>\n<p>No, don’t use Akka Actor for the message queue. Akka Actor’s mailbox doesn’t have durability, so when we send too many messages to it, the underlying JVM can explode and all the messages are gone. Just don’t do that.</p>\n<p>Also, even though Akka Persistence gives durability to Akka Actor, we should not use it as a messaging queue. The durability of Akka Persistence is specifically desigined to <em>recover Actor’s internal state in case Actor stopped</em>. </p>\n<p>Its durability is guaranteed only after the messages are processed after the Persistent Actor, so if the whole JVM is down before the sent messages are processed and persisted, you still lose the messages.</p>\n<h3>A large system of systems, with deferred operations</h3>\n<p><img src="/blog/deferred-systems-29ea730fc4213ed55adbacd13640b2de.png"></p>\n<p>Using the deferred operation approach, we can set up and integrate system of systems like the above. Something similar to like big-data-kind systems you probably saw on slides at tech conferences.</p>\n<p>In this mode, your HTTP application completely has completely different expections from the traditional “everything done in the HTTP request/response scope” mode. The HTTP client, and even the HTTP server can only expect the minimal necessary operations are completed upon sending the HTTP response, there could be delay or even failure in the deferred operations scope for the earlier requests.</p>\n<h2>Summary</h2>\n<p>Hope this article gave you a basic idea about how to implement the backend processing logic in Akka HTTP, and typical misuse of Akka Actors with Akka HTTP. </p>\n<p>Of course, there is a lot, really a lot more to think about on the implementation, so once you figured out what operations you want to perform within the HTTP request/response scope, and what can be deffered, you can go ahead looking at specific technologies like DB products, Kafka, etc to compose your whole backend. Maybe there is nothing to defer for you and everything in backend processing is in the HTTP request/response scope, and that that makes your system a lot easy to work with.</p>',frontmatter:{title:"Akka HTTP request/response scope operations, vs. Deferred operations",date:"August 05, 2018"}}},pathContext:{slug:"/akka-http-operation-scope/"}}}});
//# sourceMappingURL=path---akka-http-operation-scope-b9817ed00e19a759f70c.js.map